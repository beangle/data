/*
 * Copyright (C) 2005, The Beangle Software.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.beangle.data.dao

import net.bytebuddy.description.method.MethodDescription
import net.bytebuddy.description.modifier.Visibility
import net.bytebuddy.dynamic.DynamicType
import net.bytebuddy.dynamic.loading.ClassLoadingStrategy
import net.bytebuddy.dynamic.scaffold.TypeValidation
import net.bytebuddy.implementation.*
import net.bytebuddy.implementation.bytecode.ByteCodeAppender
import net.bytebuddy.jar.asm.{MethodVisitor, Opcodes}
import net.bytebuddy.matcher.ElementMatchers.*
import net.bytebuddy.{ByteBuddy, ClassFileVersion}
import org.beangle.commons.lang.Strings
import org.beangle.commons.lang.reflect.BeanInfos
import org.beangle.commons.lang.time.Stopwatch
import org.beangle.commons.logging.Logging
import org.beangle.data.orm.Jpas

import java.lang.reflect.Modifier
import scala.collection.mutable

trait AccessTracker {
  def ctx: AccessTracker.Context
}

object AccessTracker extends Logging {

  private val TrackerNamePostfix = "$Tracker"

  class Names(val values: mutable.LinkedHashSet[String]) {
    var last: String = _

    def access(name: String): String = {
      if (null != last && name.startsWith(last + ".") && values.lastOption.contains(last)) {
        values.remove(last)
      }
      values.add(name)
      last = name
      s"_.$last"
    }
  }

  final case class Context(names: Names, path: String) {

    def this() = {
      this(new Names(new mutable.LinkedHashSet[String]), "")
    }

    def reset(): Unit = {
      names.values.clear()
      names.last = null
    }

    def access(name: String): String = {
      val p = if Strings.isEmpty(path) then name else path + name
      names.access(p)
    }

    /** 依据路径产生一个新的上下文
     *
     * @param name
     * @return
     */
    def fork(name: String): Context = {
      if (Strings.isEmpty(path)) {
        Context(names, name + ".")
      } else {
        Context(names, path + name + ".")
      }
    }

    def accessed(): Seq[String] = {
      val rs = names.values.toSeq
      reset()
      rs
    }
  }

  private val trackers = collection.mutable.HashMap.empty[String, Class[_]]

  private val byteBuddy = buildByteBuddy()

  private def buildByteBuddy(): ByteBuddy = {
    new ByteBuddy(ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V21)).`with`(TypeValidation.DISABLED)
  }

  def of[T](clazz: Class[T]): T & AccessTracker = {
    val existing = generate(clazz)
    val tracker = existing.getConstructor(classOf[Context]).newInstance(new Context())
    tracker.asInstanceOf[T & AccessTracker]
  }

  def generate(clazz: Class[_]): Class[_] = {
    val trackerClazzName = clazz.getName + TrackerNamePostfix
    var existed = trackers.getOrElse(trackerClazzName, null)
    if (null == existed || existed == classOf[AnyRef]) {
      val manifest = BeanInfos.get(clazz)
      trackers.synchronized {
        existed = trackers.getOrElse(trackerClazzName, null)
        if (null == existed) {
          trackers.put(trackerClazzName, classOf[AnyRef]) //防止递归调用，预先占个位子
          // generate component tracker class
          manifest.properties.foreach { case (name, p) =>
            if (p.readable && p.writable && (Jpas.isComponent(p.clazz) || Jpas.isEntity(p.clazz))) {
              generate(p.clazz)
            }
          }
          // may be generated by property scanning
          existed = trackers.getOrElse(trackerClazzName, null)
          if (null == existed || existed == classOf[AnyRef]) {
            doGenerate(clazz, trackerClazzName)
          } else {
            existed
          }
        } else {
          existed
        }
      }
    } else {
      existed
    }
  }

  /** generate 代理类
   * 针对每个读方法生成一个新的方法，记录访问属性。如果该属性属于复杂类型
   * {{{
   * def gender():Gender={
   *   this._ctx.access("gender")
   *   val nctx = this._ctx.fork("gender")
   *   new Gender$Tracker(nctx)
   * }
   * }}}
   * 如属于简单类型，则直接返回字面量或者父级方法
   * {{{
   * def birthday():LocalDate={
   *   this._ctx.access("birthday")
   *   super.birthday()//or return null
   * }
   * }}}
   *
   * @param clazz            origin class
   * @param trackerClazzName tracker class name
   * @return
   */
  private def doGenerate(clazz: Class[_], trackerClazzName: String): Class[_] = {
    val watch = Stopwatch(true)
    var builder: DynamicType.Builder[_] = byteBuddy
      .subclass(if (clazz.isInterface) classOf[Object] else clazz)
      .name(trackerClazzName)
      .implement(classOf[AccessTracker])
      .defineField("_ctx", classOf[Context], Visibility.PRIVATE)
      .defineMethod("ctx", classOf[Context]).intercept(FieldAccessor.ofField("_ctx"))

    if (clazz.isInterface) {
      builder = builder.implement(clazz).defineConstructor(Modifier.PUBLIC).withParameters(classOf[Context]).intercept(
        MethodCall.invoke(classOf[Object].getConstructor()).andThen(FieldAccessor.ofField("_ctx").setsArgumentAt(0))
      )
    } else {
      builder = builder.defineConstructor(Modifier.PUBLIC).withParameters(classOf[Context]).intercept(
        MethodCall.invoke(clazz.getConstructor()).onSuper().andThen(FieldAccessor.ofField("_ctx").setsArgumentAt(0))
      )
    }

    val manifest = BeanInfos.get(clazz)
    // 处理属性
    manifest.properties.foreach { case (name, p) =>
      if (p.readable && p.writable) {
        val getter = p.getter.get
        import ByteBuddyHelper.*
        builder = builder.method(named(getter.getName)).intercept(
          new Implementation.Simple((v: MethodVisitor, c: Implementation.Context, md: MethodDescription) => {
            // 步骤1：将 this 强转为 AccessTracker 并获取 ctx
            v.visitVarInsn(Opcodes.ALOAD, 0)
            v.visitFieldInsn(Opcodes.GETFIELD, trackerClazzName.replace('.', '/'), "_ctx", notation(classOf[Context]))

            if (Jpas.isComponent(p.clazz) || Jpas.isEntity(p.clazz)) {
              // 步骤2：调用 ctx.access(method.getName)
              v.visitInsn(Opcodes.DUP)
              v.visitLdcInsn(md.getName)
              v.visitMethodInsn(Opcodes.INVOKEVIRTUAL, path(classOf[Context]), "access", s"(${notation(classOf[String])})${notation(classOf[String])}", false)
              v.visitInsn(Opcodes.POP)
              // 步骤3：调用 ctx.fork(method.getName) 创建新的ctx
              v.visitLdcInsn(md.getName)
              v.visitMethodInsn(Opcodes.INVOKEVIRTUAL, path(classOf[Context]), "fork", s"(${notation(classOf[String])})${notation(classOf[Context])}", false)
              v.visitVarInsn(Opcodes.ASTORE, 1)

              // 步骤4：new 目标类（分配内存）
              v.visitTypeInsn(Opcodes.NEW, path(p.clazz) + TrackerNamePostfix)
              v.visitInsn(Opcodes.DUP) // 复制引用（为调用构造方法准备）
              v.visitVarInsn(Opcodes.ALOAD, 1)
              // 步骤5：调用目标类的无参构造方法 <init>(context)
              v.visitMethodInsn(Opcodes.INVOKESPECIAL, path(p.clazz) + TrackerNamePostfix, "<init>", s"(${notation(classOf[Context])})V", false)
              // 步骤6：将实例作为返回值返回
              v.visitInsn(Opcodes.ARETURN)
              new ByteCodeAppender.Size(3, 2)
            } else {
              // 步骤2：调用 ctx.access(method.getName)
              v.visitLdcInsn(md.getName)
              v.visitMethodInsn(Opcodes.INVOKEVIRTUAL, path(classOf[Context]), "access", s"(Ljava/lang/String;)${notation(classOf[String])}", false)

              //如果是不要求返回字符串，则出栈一条
              if (!md.getReturnType.represents(classOf[String])) {
                v.visitInsn(Opcodes.POP)
                if (clazz.isInterface) {
                  appendLiteralToStack(v, md)
                } else {
                  //步骤3： super.getXXX
                  v.visitVarInsn(Opcodes.ALOAD, 0)
                  v.visitMethodInsn(Opcodes.INVOKESPECIAL, path(clazz), md.getName, md.getDescriptor, false)
                }
              }
              v.visitInsn(getReturnOpcode(md))
              new ByteCodeAppender.Size(2, 1)
            }
          })
        )
      }
    }

    // 生成并加载类
    val dynamicType = builder.make()
    //dynamicType.saveIn(new java.io.File(SystemInfo.tmpDir))
    //println(SystemInfo.tmpDir)
    val generated = dynamicType.load(clazz.getClassLoader, ClassLoadingStrategy.Default.INJECTION).getLoaded
    logger.debug(s"generate $trackerClazzName using $watch")
    trackers.put(trackerClazzName, generated)
    generated
  }

  def cleanup(): Unit = {
    trackers.clear()
  }

}
