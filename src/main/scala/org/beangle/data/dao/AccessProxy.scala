/*
 * Copyright (C) 2005, The Beangle Software.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.beangle.data.dao

import net.bytebuddy.description.method.MethodDescription
import net.bytebuddy.description.modifier.Visibility
import net.bytebuddy.dynamic.DynamicType
import net.bytebuddy.dynamic.loading.ClassLoadingStrategy
import net.bytebuddy.dynamic.scaffold.TypeValidation
import net.bytebuddy.implementation.*
import net.bytebuddy.implementation.bytecode.ByteCodeAppender
import net.bytebuddy.jar.asm.{MethodVisitor, Opcodes}
import net.bytebuddy.matcher.ElementMatchers.*
import net.bytebuddy.{ByteBuddy, ClassFileVersion}
import org.beangle.commons.lang.Strings
import org.beangle.commons.lang.reflect.BeanInfos
import org.beangle.commons.lang.time.Stopwatch
import org.beangle.commons.logging.Logging
import org.beangle.data.orm.Jpas

import java.lang.reflect.Modifier
import scala.collection.mutable

trait AccessProxy {
  def ctx: AccessProxy.Context
}

object AccessProxy extends Logging {

  private val ProxyNamePostfix = "$AccessProxy"

  class Names(val values: mutable.LinkedHashSet[String]) {
    var last: String = _

    def access(name: String): Unit = {
      if (null != last && name.startsWith(last + ".") && values.lastOption.contains(last)) {
        values.remove(last)
      }
      values.add(name)
      last = name
    }
  }

  final case class Context(names: Names, path: String) {

    def this() = {
      this(new Names(new mutable.LinkedHashSet[String]), "")
    }

    def reset(): Unit = {
      names.values.clear()
      names.last = null
    }

    def access(name: String): Unit = {
      val p = if Strings.isEmpty(path) then name else path + name
      names.access(p)
    }

    def fork(name: String): Context = {
      if (Strings.isEmpty(path)) {
        Context(names, name + ".")
      } else {
        Context(names, path + name + ".")
      }
    }

    def accessed(): Seq[String] = {
      val rs = names.values.toSeq
      reset()
      rs
    }
  }

  private val proxies = collection.mutable.HashMap.empty[String, Class[_]]

  private val byteBuddy = buildByteBuddy()

  private def buildByteBuddy(): ByteBuddy = {
    new ByteBuddy(ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V21)).`with`(TypeValidation.DISABLED)
  }

  def of[T](clazz: Class[T]): T & AccessProxy = {
    val existing = generate(clazz)
    val proxy = existing.getConstructor(classOf[Context]).newInstance(new Context())
    proxy.asInstanceOf[T & AccessProxy]
  }

  def generate(clazz: Class[_]): Class[_] = {
    val proxyClazzName = clazz.getName + ProxyNamePostfix
    var existed = proxies.getOrElse(proxyClazzName, null)
    if (null == existed) {
      proxies.put(proxyClazzName, classOf[AnyRef])
      val manifest = BeanInfos.get(clazz)
      // generate component proxy class
      manifest.properties.foreach { case (name, p) =>
        if (p.readable && p.writable && (Jpas.isComponent(p.clazz) || Jpas.isEntity(p.clazz))) {
          generate(p.clazz)
        }
      }
      // may be generated by property scanning
      existed = proxies.getOrElse(proxyClazzName, null)
      if (null == existed || existed == classOf[AnyRef]) {
        doGenerate(clazz, proxyClazzName)
      } else {
        existed
      }
    } else {
      existed
    }
  }

  /** generate 代理类
   * 针对每个读方法生成一个新的方法，记录访问属性。如果该属性属于复杂类型
   * {{{
   * def gender():Gender={
   *   this._ctx.access("gender")
   *   val nctx = this._ctx.fork("gender")
   *   new Gender$AccessProxy(nctx)
   * }
   * }}}
   * 如属于简单类型，则直接返回字面量或者父级方法
   * {{{
   * def birthday():LocalDate={
   *   this._ctx.access("birthday")
   *   super.birthday()//or return null
   * }
   * }}}
   *
   * @param clazz
   * @param proxyClazzName
   * @return
   */
  private def doGenerate(clazz: Class[_], proxyClazzName: String): Class[_] = {
    val watch = Stopwatch(true)
    var builder: DynamicType.Builder[_] = byteBuddy
      .subclass(if (clazz.isInterface) classOf[Object] else clazz)
      .name(proxyClazzName)
      .implement(classOf[AccessProxy])
      .defineField("_ctx", classOf[Context], Visibility.PRIVATE)
      .defineMethod("ctx", classOf[Context]).intercept(FieldAccessor.ofField("_ctx"))

    if (clazz.isInterface) {
      builder = builder.implement(clazz).defineConstructor(Modifier.PUBLIC).withParameters(classOf[Context]).intercept(
        MethodCall.invoke(classOf[Object].getConstructor()).andThen(FieldAccessor.ofField("_ctx").setsArgumentAt(0))
      )
    } else {
      builder = builder.defineConstructor(Modifier.PUBLIC).withParameters(classOf[Context]).intercept(
        MethodCall.invoke(clazz.getConstructor()).onSuper().andThen(FieldAccessor.ofField("_ctx").setsArgumentAt(0))
      )
    }

    val manifest = BeanInfos.get(clazz)
    // 处理属性
    manifest.properties.foreach { case (name, p) =>
      if (p.readable && p.writable) {
        val getter = p.getter.get
        import ByteBuddyHelper.*
        builder = builder.method(named(getter.getName)).intercept(
          new Implementation.Simple((v: MethodVisitor, c: Implementation.Context, md: MethodDescription) => {
            // 步骤1：将 proxy 强转为 AccessProxy 并获取 ctx
            v.visitVarInsn(Opcodes.ALOAD, 0)
            v.visitFieldInsn(Opcodes.GETFIELD, proxyClazzName.replace('.', '/'), "_ctx", notation(classOf[Context]))

            if (Jpas.isComponent(p.clazz) || Jpas.isEntity(p.clazz)) {
              // 步骤2：调用 ctx.access(method.getName)
              v.visitInsn(Opcodes.DUP)
              v.visitLdcInsn(md.getName)
              v.visitMethodInsn(Opcodes.INVOKEVIRTUAL, path(classOf[Context]), "access", s"(${notation(classOf[String])})V", false)

              // 步骤3：调用 ctx.fork(method.getName) 创建新的ctx
              v.visitLdcInsn(md.getName)
              v.visitMethodInsn(Opcodes.INVOKEVIRTUAL, path(classOf[Context]), "fork", s"(${notation(classOf[String])})${notation(classOf[Context])}", false)
              v.visitVarInsn(Opcodes.ASTORE, 1)

              // 步骤4：new 目标类（分配内存）
              v.visitTypeInsn(Opcodes.NEW, path(p.clazz) + ProxyNamePostfix)
              v.visitInsn(Opcodes.DUP) // 复制引用（为调用构造方法准备）
              v.visitVarInsn(Opcodes.ALOAD, 1)
              // 步骤5：调用目标类的无参构造方法 <init>(context)
              v.visitMethodInsn(Opcodes.INVOKESPECIAL, path(p.clazz) + ProxyNamePostfix, "<init>", s"(${notation(classOf[Context])})V", false)
              // 步骤6：将实例作为返回值返回
              v.visitInsn(Opcodes.ARETURN)
              new ByteCodeAppender.Size(3, 2)
            } else {
              // 步骤2：调用 ctx.access(method.getName)
              v.visitLdcInsn(md.getName)
              v.visitMethodInsn(Opcodes.INVOKEVIRTUAL, path(classOf[Context]), "access", "(Ljava/lang/String;)V", false)

              if (clazz.isInterface) {
                appendLiteralToStack(v, md)
              } else {
                //步骤3： super.getXXX
                v.visitVarInsn(Opcodes.ALOAD, 0)
                v.visitMethodInsn(Opcodes.INVOKESPECIAL, path(clazz), md.getName, md.getDescriptor, false)
              }
              v.visitInsn(getReturnOpcode(md))
              new ByteCodeAppender.Size(2, 1)
            }
          })
        )
      }
    }

    // 生成并加载类
    val dynamicType = builder.make()
    //dynamicType.saveIn(new java.io.File(SystemInfo.tmpDir))
    val generated = dynamicType.load(clazz.getClassLoader, ClassLoadingStrategy.Default.INJECTION).getLoaded
    logger.debug(s"generate $proxyClazzName using $watch")
    proxies.put(proxyClazzName, generated)
    generated
  }

  def cleanup(): Unit = {
    proxies.clear()
  }

}
